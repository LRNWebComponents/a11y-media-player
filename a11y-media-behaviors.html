<link rel="import" href="../responsive-utility/responsive-utility.html">
<!--
`a11y-media-behaviors`
A set of behaviors for a11y-media components.
@microcopy - the mental model for this element
 - 
 - 
-->

<script>
  window.a11yMediaBehaviors = window.a11yMediaBehaviors || {};
  window.a11yMediaBehaviors.MediaProps = {
    properties: {
      /** 
        * autoplay is an option, 
        * but generally not recommended for a11y
        */ 
      autoplay: {
        type: Boolean,
        value: false,
      },
      /**
        * show closed captions
        */
      cc: {
        type: Boolean,
        value: false,
      },
      /** 
        * The width of the media player. 
        */
      height: {
        type: String,
        value: 'unset'
      },
      /**
        * Language
        */
      lang: {
        type: String,
        value: 'en',
      },
      /** 
        * Loop the video?
        */
      loop: {
        type: Boolean,
        value: false,
      },
      /** 
        * Is audio muted?
        */
      muted: {
        type: Boolean,
        value: false,
      },
      /**
        * Playback rate where 1 is normal speed, 0.5 is half-speed, and 2 is double speed
        */
      playbackRate: {
        type: Number,
        value: 1
      },
      /**
        * status
        */
      status: {
        type: String,
        value: 'loading...',
      },
      /**
        * the selected track
        */
      selectedTrack: {
        type: Object,
        value: null,
      },
      /**
        * id of the selected track
        */
      selectedTrackID: {
        type: Number,
        value: null,
      },
      /** 
        * array of tracks and cues
        */
      tracks: {
        type: Array,
        value: null
      },
      /** 
        * Range is 0 to 100. Default should not be loud enough to overpower screen readers. 
        */
      volume: {
        type: Number,
        value: 70
      },
      /** 
        * The width of the media player. 
        */
      width: {
        type: String,
        value: 'unset'
      },

    },
  };
  window.a11yMediaBehaviors.GeneralFunctions = {
    /**
      * calls responsive-utility to get parent's responsive size
      */ 
    _addResponsiveUtility: function(data){
      let root = this, data2 = data !== undefined ? data : {
        "element": root,
        "attribute": "responsive-size",
        "relativeToParent": true,
      };
      Polymer.ResponsiveUtility.requestAvailability();
      root.fire('responsive-element',data2);
    },
    /**
      * set play/pause button 
      */
    _convertTime: function(val,max){
      max = max === undefined ? val : max;
      let a = (val) => { return val < 10 ? '0' + val : val; }, 
      b = (val,i,none) => { return max >= i ? a(Math.floor(val/i))+':' : none },
      c = (val) => { return val < 100 ? val+'0' : val };
      return b(val,3600,'')+b(val%3600,60,'00:')+a(Math.round(val%60));
    }
  };
  window.a11yMediaBehaviors.UILanguageProps = {
      /**
        * label/microcopy for audio
        */
      audioLabel: {
        type: String,
        value: "audio"
      },
      /**
        * icon for closed captions button on player controls
        */
      captionsIcon: {
        type: String,
        value: "av:closed-caption"
      },
      /**
        * label for closed captions button on player controls
        */
      captionsLabel: {
        type: String,
        value: "closed captions"
      },
      /**
        * label for captions drop-down menu on settings menu of player controls
        */
      captionsMenuLabel: {
        type: String,
        value: "Captions"
      },
      /**
        * label for captions off drop-down menu item on settings menu of player controls
        */
      captionsMenuOff: {
        type: String,
        value: "Off"
      },
      /**
        * the interface UI language
        */
      uiLanguage: {
        type: String,
        value: "en"
      },
      /**
        * icon for forward button on player controls
        */
      forwardIcon: {
        type: String,
        value: "av:fast-forward"
      },
      /**
        * label for rewind button on player controls
        */
      forwardLabel: {
        type: String,
        value: "forward"
      },
      /**
        * icon for fullscreen button on transcript
        */
      fullscreenIcon: {
        type: String,
        value: "fullscreen"
      },
      /**
        * label for fullscreen button on transcript
        */
      fullscreenLabel: {
        type: String,
        value: "fullscreen"
      },
      /**
        * label for loop menu item on settings menu of player controls
        */
      loopLabel: {
        type: String,
        value: "Loop Playback"
      },
      /**
        * icon for mute button on player controls
        */
      muteIcon: {
        type: String,
        value: "av:volume-up"
      },
      /**
        * label for fullscreen button on player controls
        */
      muteLabel: {
        type: String,
        value: "mute"
      },
      /**
        * icon for pause button on player controls
        */
      pauseIcon: {
        type: String,
        value: "av:pause"
      },
      /**
        * label for pause button on player controls
        */
      pauseLabel: {
        type: String,
        value: "pause"
      },
      /**
        * icon for play button on player controls
        */
      playIcon: {
        type: String,
        value: "av:play-arrow"
      },
      /**
        * label for play button on player controls
        */
      playLabel: {
        type: String,
        value: "play"
      },
      /**
        * icon for restart button on player controls
        */
      restartIcon: {
        type: String,
        value: "av:replay"
      },
      /**
        * label for restart button on player controls
        */
      restartLabel: {
        type: String,
        value: "restart"
      },
      /**
        * icon for rewind button on player controls
        */
      rewindIcon: {
        type: String,
        value: "av:fast-rewind"
      },
      /**
        * label for rewind button on player controls
        */
      rewindLabel: {
        type: String,
        value: "backward"
      },
      /**
        * icon for settings menu on player controls
        */
      settingsIcon: {
        type: String,
        value: "settings"
      },
      /**
        * label for settings menu on player controls
        */
      settingsLabel: {
        type: String,
        value: "settings"
      },
      /**
        * label for speed menu item on settings menu of player controls
        */
      speedLabel: {
        type: String,
        value: "Speed %"
      },
      /**
        * icon for transcript button on player controls
        */
      transcriptIcon: {
        type: String,
        value: "description"
      },
      /**
        * label for transcript button on player controls
        */
      transcriptLabel: {
        type: String,
        value: "transcript"
      },
      /**
        * label for transcript menu item on settings menu of player controls
        */
      transcriptMenuLabel: {
        type: String,
        value: "Transcript"
      },
      /**
        * icon for unmute button on player controls
        */
      unmuteIcon: {
        type: String,
        value: "av:volume-off"
      },
      /**
        * label for unmute button on player controls
        */
      unmuteLabel: {
        type: String,
        value: "unmute"
      },
      /**
        * label/microcopy for audio
        */
      videoLabel: {
        type: String,
        value: "video"
      },
      /**
        * label for volume slider on player controls
        */
      volumeLabel: {
        type: String,
        value: "volume"
      },
  };
  window.a11yMediaBehaviors.PlayerBehaviors = {
    properties: {
      /** 
        * Accent color on controls. Default is blue.
        */ 
      accentColor: {
        type: String,
        value: null,
        reflectToAttribute: true,
      },
      /** 
        * Allow this media to play concurrently with other a11y-media-standalone-players? 
        * Default is to pause this a11y-media-standalone-player when other a11y-media-standalone-player starts playing.
        */ 
      allowConcurrent: {
        type: Boolean,
        value: false,
        reflectToAttribute: true,
      },
      /** 
        * Is this an audio file?
        */ 
      audioOnly: {
        type: Boolean,
        value: false,
        reflectToAttribute: true,
      },
      /**
        * Use compact controls?
        */
      compactControls: {
        type: Boolean,
        computed: '_getCompactControls(responsiveSize)',
        reflectToAttribute: true
      },
      /** 
        * disable fullscreen option 
        */
      dark: {
        type: Boolean,
        value: false,
        reflectToAttribute: true
      },
      /** 
        * disable fullscreen option 
        */
      disableFullscreen: {
        type: Boolean,
        value: false,
      },
      /** 
        * Is fullscreen mode?
        */
      fullscreen: {
        type: Boolean,
        value: false,
      },
      /**
        * show the FullscreenButton?
        */
      fullscreenButton: {
        type: Boolean,
        computed: '_getFullscreenButton(disableFullscreen)',
        notify: true
      },
      /** 
        * Does the player have tracks?
        */
      hasCaptions: {
        type: Boolean,
        value: false,
      },
      /** 
        * Does the player have an interactive transcript?
        */
      hasTranscript: {
        type: Boolean,
        value: false,
      },
      /** 
        * Hide elapsed time?
        */
      hideElapsedTime: {
        type: Boolean,
        value: false,
      },
      /** 
        * Hide the transcript?
        */
      hideTranscript: {
        type: Boolean,
        value: false,
        reflectToAttribute: true,
      },
      /**
        * optional title of media (shows when printed)
        */
      mediaTitle: {
        type: String,
        value: '',
        reflectToAttribute: true,
      },
      /**
        * Is it an audio player with no thumbnail?
        */
      noHeight: {
        type: Boolean,
        computed: '_getNoHeight(audioOnly,thumbnailSrc)',
        reflectToAttribute: true
      },
      /**
        * Is media playing?
        */
      playing: {
        type: Boolean,
        value: false
      },
      /**
        * Size of the a11y media element for responsive styling
        */
      responsiveSize: {
        type: String,
        notify: true,
        reflectToAttribute: true
      },
      /** 
        * Is the video currently sticky, i.e. it is fixed to the corner when playing but scrolled off screen? 
        */
      sticky: {
        type: Boolean,
        value: false,
        reflectToAttribute: true
      },
      /** 
        * When playing but scrolled off screen, to which corner does it stick: 
        * top-left, top-right, bottom-left, bottom-right, or none? 
        * Default is "top-right". "None" disables stickiness.
        */
      stickyCorner: {
        type: String,
        value: 'top-right',
        reflectToAttribute: true
      },
      /**
        * Source of optional thumbnail image
        */
      thumbnailSrc: {
        type: String,
        value: null,
        reflectToAttribute: true
      },
    },
    /** 
     * plays the media 
     */
    play: function(e){
      let root = this;
      root.__playing = true;
      if (e === undefined || e.detail === root.$.playbutton) {
        // while playing, update the slider and length
        root.__playProgress = setInterval(() => {
          root.__elapsed = root.__src.currentTime > 0 ? root.__src.currentTime : 0;
          root.__status = root._convertTime(root.__src.currentTime,root.__src.duration) +'/'+ root._convertTime(root.__src.duration);
          root.$.controls.setStatus(root.__status);
          // if the video reaches the end and is not set to loop, stop
          if(root.__elapsed === root.__duration && !root.loop){
            root.__playing = false;
            clearInterval(root.__playProgress);
          }
          
          //updated buffered section of the slider
          root.__buffered = root.__src.buffered.length > 0 ? root.__src.buffered.end(0) : root.__elapsed;
        }, 1);
        root.fire('a11y-player-playing',root);
        root.__src.play();
      }
    },
    /** 
     * pauses the media 
     */
    pause: function(){
      let root = this;
      root.__playing = false;
      root.__src.pause();

      //stop updating the slider and length
      clearInterval(root.__playProgress); 
    },
    /** 
     * stops the media 
     */
    stop: function(){
      this.pause();
      this.seek(0);
    },
    /** 
     * restarts the media 
     */
    restart: function(){
      this.seek(0);
      this.play();
    },
    /** 
     * seeks media backward at a set increment
     */
    rewind: function(amt){
      amt = amt !== undefined ? amt : 1;
      this.seek(Math.max(this.__src.currentTime - amt,0));
    },
    /** 
     * seeks media forward at a set increment
     */
    forward: function(amt){
      amt = amt !== undefined ? amt : 1;
      this.seek(Math.min(this.__src.currentTime + amt,this.__src.duration));
    },
    /** 
     * seeks to a specific time 
     */
    seek: function(time){
      let seekable = this.__src.seekable;
      if (seekable.length > 0 && time >= seekable.start(0) && time <= seekable.end(0)) {
        this.__src.currentTime = time;
        this.__elapsed = time;
        this.__length = this._convertTime(this.__src.currentTime,this.__src.duration) +'/'+ this._convertTime(this.__src.duration);
        if (this.__resumePlaying) this.play();
      }
    },
    /** 
     * toggles captions:
     * toggleCC(true) to check the toggle, toggleCC(false) for unchecking, and toggleCC to toggle  
     */
    toggleCC: function(mode){
      mode = mode === undefined ? !this.cc : mode;
      this.cc = mode;
      if (this.__selectedTrack !== undefined && mode == true) {
        this.__selectedTrack.mode = 'showing';
        this.$.video.textTracks.value = this.__selectedTrackId;
      } else if (this.__selectedTrack !== undefined) {
        this.__selectedTrack.mode = 'hidden';
        this.$.video.textTracks.value = '';
      }
    },
    /** 
     * set volume of media
     */
    setVolume: function(value){
      this.volume = value !== null ? value : 70;
      this.__src.volume = this.volume !== null ? value/100 : 0.7;
      this.muted = value === null || value === 0;
    },
    /** 
     * set speed/playback rate of media
     */
    setPlaybackRate: function(value){
      this.__src.playbackRate = value !== null ? value : 1;
    },
    /** 
     * toggles autoplay:
     * toggleAutoplay(true) to check the toggle, 
     * toggleAutoplay(false) for unchecking, and 
     * toggleAutoplay to toggle  
     */
    toggleAutoplay: function(mode){
      mode = mode === undefined ? !this.muted : mode;
      this.autoplay = mode;
    },
    /** 
     * toggles looping:
     * toggleLoop(true) to check the toggle, toggleLoop(false) for unchecking, and toggleLoop to toggle  
     */
    toggleLoop: function(mode){
      mode = mode === undefined ? !this.loop : mode;
      this.loop = mode;
    },
    /** 
     * toggles mute:
     * toggleMute(true) to check the toggle, 
     * toggleMute(false) for unchecking, and 
     * toggleMute to toggle  
     */
    toggleMute: function(mode){
      mode = mode === undefined ? !this.muted : mode;
      this.muted = mode;
      this.__volume = this.muted ? 0 : Math.max(this.volume,10);
      this.__src.volume = this.muted ? 0 : Math.max(this.volume/100,0.1);
      this.__src.muted = this.muted;
    },
    /** 
     * toggles sticky attribute:
     * toggleSticky(true) to stick, toggleSticky(false) for unstick, and toggleSticky to toggle sticky 
     */
    toggleSticky: function(mode){
      mode = mode === undefined ? !this.sticky : mode;
      this.sticky = mode;
      this.fire('player-sticky', this);
    },
    /** 
     * toggles transcript:
     * toggleTranscript(true) to check the toggle, toggleTranscript(false) for unchecking, and toggleTranscript to toggle  
     */
    toggleTranscript: function(mode){
      mode = mode === undefined ? this.hideTranscript : mode;
      this.hideTranscript = !mode;
      if (this.__transcript !== undefined && this.__transcript !== null) {
        this.fire('transcript-toggle',this);
        this.__transcript.toggleHidden(this.hideTranscript);
      }
    },
    /**
     * determine which button was clicked and act accordingly 
     */
    _onControlsChanged: function(e){
      let root = this, action = e.detail.label !== undefined ? e.detail.label : e.detail.id;
      if (action === 'backward' || action === root.rewindLabel) {
        root.rewind(root.__src.duration/20);
      } else if (action === 'closed captions' || action === 'captions' || action === root.captionsLabel  || action === root.captionsMenuLabel) {
        root.toggleCC();
      } else if (action === 'transcript' || action === 'transcript-toggle' || action === root.transcriptLabel  || action === root.transcriptMenuLabel) {
        root.toggleTranscript();
      } else if (e.detail.id === 'tracks') {
        if(e.detail.value === '') {
          root.toggleCC(false);
        } else {
          root.toggleCC(true);
          root.selectTrack(e.detail.value);
        }
      } else if (action === 'forward' || action === root.forwardLabel) {
        root.forward(root.__src.duration/20);
      } else if (action === 'full screen' || action === root.fullscreenLabel) {
        screenfull.toggle(root);
      } else if (action === 'loop' || action === root.loopLabel) {
        root.toggleLoop();
      } else if (action === 'mute' || action === 'unmute' || action === root.muteLabel || action === root.unmuteLabel ) {
        root.toggleMute();
      } else if (action === 'pause' || action === root.pauseLabel) {
        root.pause();
      } else if (action === 'play' || action === root.playLabel) {
        root.play();
      } else if (action === 'restart' || action === root.restartLabel) {
        root.seek(0);
        root.play();
      } else if (action === 'speed' || action === root.speedLabel) {
        root.setPlaybackRate(e.detail.value);
      } else if (action === 'volume' || action === root.volumeLabel) {
        root.setVolume(e.detail.value);
      }
    },
    /**
      * returns true if an attribute is set to a value
      */ 
    _getNoHeight: function(audioOnly,thumbnailSrc){
      return audioOnly && (thumbnailSrc === null || thumbnailSrc === undefined);
    },
    /**
      * returns true if an attribute is set to a value
      */ 
    _getFullscreenButton: function(disableFullscreen){
      if( /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || disableFullscreen) {
        return false;
      } else {
        return true;
      }
    },
    /**
      * returns true if player is xs or sm and needs to use compact controls
      */ 
    _getCompactControls: function(responsiveSize){
      return this._testAttribute(responsiveSize,"xs") || this._testAttribute(responsiveSize,"sm");
    },
    /**
      * returns true if an attribute is set to a value
      */ 
    _testAttribute: function(attr,val){
      return attr === val;
    }
  };
  window.a11yMediaBehaviors.TranscriptBehaviors = {
    properties: {
      /** 
        * Accent color on controls. Default is blue.
        */ 
      accentColor: {
        type: String,
        value: null,
        reflectToAttribute: true,
      },
      /** 
        * disable interactive mode that makes the transcript clickable 
        */
      disableInteractive: {
        type: Boolean,
        value: false,
      },
      /** 
        * disable transcript search feature 
        */
      disableSearch: {
        type: Boolean,
        value: false,
      },
      /** 
        * disable autoscrolling as transcript plays 
        */
      disableScroll: {
        type: Boolean,
        value: false,
      },
      /** 
        * disable transcript print button
        */
      disablePrintButton: {
        type: Boolean,
        value: false,
      },
      /**
        * show cue's start and end time 
        */
      hideTimestamps: {
        type: Boolean,
        value: false,
      },
      /**
        * show cue's start and end time 
        */
      media: {
        type: Object,
        value: {},
      },
      /**
        * the search tool for the transcript
        */
      search: {
        type: Object,
        value: null,
      },
      /**
        * selected transcript track id
        */
      selectedTranscript: {
        type: String,
        value: '0',
      },
      /**
        * label for search input  on transcript
        */
      searchLabel: {
        type: String,
        value: "search transcript"
      },
      /**
        * icon for search input on transcript
        */
      searchIcon: {
        type: String,
        value: "search"
      },
      /**
        * label for the next button on transcript search
        */
      searchNextButtonLabel: {
          type: String,
          value: "next result"
        },
      /**
        * icon for the next button on transcript search
        */
      searchNextButtonIcon: {
          type: String,
          value: "arrow-forward"
        },
      /**
        * label for the previous button on transcript search
        */
      searchPrevButtonLabel: {
          type: String,
          value: "previous result"
        },
      /**
        * icon for the previous button on transcript search
        */
      searchPrevButtonIcon: {
          type: String,
          value: "arrow-back"
        },
      /**
        * label for autoscroll button on transcript controls
        */
      autoScrollLabel: {
        type: String,
        value: "auto-scrolling"
      },
      /**
        * icon for autoscroll button on transcript controls
        */
      autoScrollIcon: {
        type: String,
        value: "swap-vert"
      },
      /**
        * label for print button on player controls
        */
      printLabel: {
        type: String,
        value: "print transcript"
      },
      /**
        * icon for print button on player controls
        */
      printIcon: {
        type: String,
        value: "print"
      },
      /**
        * label for skip the transcript link before the transcript
        */
      skipTranscriptLink: {
        type: String,
        value: "Skip the transcript."
      }
    }
  };
</script>

