<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="a11y-media-youtube-utility.html">


<!--
`a11y-media-youtube-loader`
A LRN element

@demo demo/index.html

@microcopy - the mental model for this element

  <a11y-media-youtube-loader 
    accent-color$="[[accentColor]]"             // Optional accent color for controls, 
                                                // using the following materialize colors: 
                                                // red, pink, purple, deep-purple, indigo, blue, 
                                                // light blue, cyan, teal, green, light green, lime, 
                                                // yellow, amber, orange, deep-orange, and brown. 
                                                // Default is null. 
    allow-fullscreen$="[[allowFullscreen]]"         // Allow fullscreen mode?
    audio-only$="[[audioOnly]]"                 // Is media audio only?
    autoplay$="[[autoplay]]"                    // Is player set to autoplay (not recommended for a11y)?
    cc$="[[cc]]"                                // Are closed captions toggled?
    custom-microcopy$="[[customMicrocopy]]"     // Optional customization or text and icons
    dark$="[[dark]]"                            // Is the color scheme dark? Default is light.    
    disableFullscreen$="[[disableFullscreen]]"  // Is full screen mode disabled?
    fullscreen$="[[fullscreen]]"                // Is full screen mode toggled on?
    height$="[[height]]"                        // The height of player
    hide-elapsed-time$="[[hideElapsedTime]]"    // Is elapsed time hidden?
    lang$="[[lang]]"                            // The language of the media
    loop$="[[loop]]"                            // Is video on a loop?
    muted$="[[muted]]"                          // Is video muted?
    volume$="[[volume]]"                        // The initial volume of the video
    width$="[[width]]">                         // The width of player
                                                // video source and tracks 
    <source src="/path/to/video.mp4" type="video/mp4">
    <source src="/path/to/video.webm" type="video/webm">
    <track label="English" kind="subtitles" srclang="en" src="path/to/subtitles/en.vtt" default>
    <track label="Deutsch" kind="subtitles" srclang="de" src="path/to/subtitles/de.vtt">
    <track label="EspaÃ±ol" kind="subtitles" srclang="es" src="path/to/subtitles/es.vtt">
  </a11y-media-youtube-loader>
-->

<dom-module id="a11y-media-youtube-loader">
  <template>
    <style is="custom-style">
      #youtube, #controls {
        width: 600px;
      }
    </style>
    <div id="youtube" video-id$="[[videoId]]"></div>
  </template>

  <script>
    Polymer({

      is: 'a11y-media-youtube-loader',
      
      behaviors: [ 
        a11yMediaBehaviors.MediaProps, 
        a11yMediaBehaviors.GeneralFunctions 
      ], 

      properties: {
        videoId: {
          type: String,
          value: 'u1zgFlCw8Aw'
        },
        player: {
          type: Object,
          value: {}
        }
      },

      attached: function(){
        Polymer.A11yMediaYoutubeUtility.requestAvailability();
      },
      ready: function(){
        let root = this, initPlayer = function(){
          root.media = Polymer.A11yMediaYoutubeUtility.initYoutubePlayer(root.$.youtube);
          root.duration = root.media.getDuration(); 
          root.status = root._convertTime(0,root.duration)+'/'+root._convertTime(root.duration);
          root.volume = root.muted ? 0 : Math.max(this.volume,10);
          root.setVolume(root.volume);

          // adjusts aspect ratio
          if(root.width !== undefined && root.height !== undefined){
            root.aspectRatio = root.width / root.height * 100;
          } else {
            root.aspectRatio = root.aspectRatio !== undefined ? root.aspectRatio : 1600/9;
            if (root.width === undefined && root.height !== undefined) {
              root.width = (root.height * root.aspectRatio / 100);
            } else (root.width !== undefined && root.height == undefined) {
              root.width = root.width !== undefined ? root.width : '640';
              root.height = (root.width / root.aspectRatio / 100);
            } 
          }
          root.aspectRatio = root.media.videoHeight/root.media.videoWidth * 100;
          root.media.setSize(root.width, root.height);
          console.log(root);
        }; 
        root.status = 'Loading...';
        if(Polymer.A11yMediaYoutubeUtility.apiReady){
          initPlayer();
        } else {
          document.addEventListener('youtube-api-ready', function(e) {
            initPlayer();
          });
        }

        //adjusts video width and height based on attributes
        /*TODO player.getVideoLoadedFraction():Float
        /* TODO
        // handles loaded metadata
        root.addEventListener('loadedmetadata',function(){
          // adjusts aspect ratio*/
          //TODO root.aspectRatio = root.media.videoHeight/root.media.videoWidth * 100;
          //TODO root.tracks = [];
          
          // gets cues from tracks
          /* TODO 
          let tracks = [];
          for(i in root.media.textTracks) {
            if (root.media.textTracks[i] !== null) {
              let track = root.media.textTracks[i], loaded = track.cues !== undefined, complete = 0, label = track.label, lang = track.language, text = label !== undefined ? label : lang !== undefined ? lang : 'Track '+i, cues;
              
              root.setAttribute('has-captions',true);
              if(!loaded) {
                track.mode = 'showing';
                let temp = setInterval(() => {
                  if (track.cues.length > 0) {
                    track.mode = 'hidden';
                    let cues = Object.keys(track.cues).map(function(key) { 
                      return {
                        "order": track.cues[key].id,
                        "seek": track.cues[key].startTime,
                        "start": root._convertTime(track.cues[key].startTime,root.media.duration),
                        "end": root._convertTime(track.cues[key].endTime,root.media.duration), 
                        "text": track.cues[key].text
                      };
                      tracks.push({
                        'text': text, 
                        'language': track.language, 
                        'value': i,
                        'curs': cues
                      });
                      track.oncuechange = function(e){
                        this.fire('active-cue-change',Object.keys(e.currentTarget.activeCues).map(function(key) { 
                          return e.currentTarget.activeCues[key].id;
                        }));
                      };
                    });
                    complete++;
                    if (complete === tracks.length && root.__transcript !== null) {
                      root.set('tracks', tracks);
                      root.fire('tracks-loaded',root.tracks);
                    }
                    clearInterval(temp);
                  }
                },1);
              }
            }
          }
        });*/
      },
      /** 
       * selects a specific track by index
       */
      /*TODO
      selectTrack: function(index){
        for(i in this.media.textTracks) {
          if (index == i) {
            this.media.textTracks[i].mode = 'showing';
            this.selectedTrack = this.media.textTracks[i];
            this.selectedTrackId = i;
          } else if (this.media.textTracks[i] !== null) {
            this.media.textTracks[i].mode = 'hidden';
          }
        }
      },*/
      /** 
       * plays the media 
       */
      play: function(){
        this.media.playVideo();
      },
      /** 
       * pauses the media 
       */
      pause: function(){
        this.media.pauseVideo(); 
      },
      /** 
       * stops the media 
       */
      stop: function(){
        this.pause();
        this.seek(0);
      },
      /** 
       * restarts the media 
       */
      restart: function(){
        this.seek(0);
        this.play();
      },
      /** 
       * seeks media backward at a set increment
       */
      rewind: function(amt){
        amt = amt !== undefined ? amt : 1;
        this.seek(Math.max(this.media.getCurrentTime() - amt, 0));
      },
      /** 
       * seeks media forward at a set increment
       */
      forward: function(amt){
        amt = amt !== undefined ? amt : 1;
        this.seek(Math.min(this.media.getCurrentTime() + amt,this.media.duration));
      },
      /** 
       * seeks to a specific time 
       */
      seek: function(time){
        this.media.seekTo = time;
      },
      /** 
       * toggles captions:
       * toggleCC(true) to check the toggle, toggleCC(false) for unchecking, and toggleCC to toggle  
       */
      toggleCC: function(mode){
        mode = mode === undefined ? !this.cc : mode;
        this.cc = mode;
        if (this.selectedTrack !== undefined && mode == true) {
          this.selectedTrack.mode = 'showing';
          this.$.video.textTracks.value = this.selectedTrackId;
        } else if (this.selectedTrack !== undefined) {
          this.selectedTrack.mode = 'hidden';
          this.$.video.textTracks.value = '';
        }
      },
      /** 
       * set volume of media
       */
      setVolume: function(value){
        this.media.volume = value;
        this.media.muted = value === null || value === 0;
      },
      /** 
       * set speed/playback rate of media
       */
      setPlaybackRate: function(value){
        this.media.setPlaybackRate(value !== null ? value : 1);
      },
      /** 
       * toggles autoplay:
       * toggleAutoplay(true) to check the toggle, 
       * toggleAutoplay(false) for unchecking, and 
       * toggleAutoplay to toggle  
       */
      toggleAutoplay: function(mode){
        mode = mode === undefined ? !this.muted : mode;
        this.media.autoplay = mode;
      },
      /** 
       * toggles looping:
       * toggleLoop(true) to check the toggle, toggleLoop(false) for unchecking, and toggleLoop to toggle  
       */
      toggleLoop: function(mode){
        mode = mode === undefined ? !this.loop : mode;
        this.media.setLoop(mode);
      },
      /** 
       * toggles mute:
       * toggleMute(true) to check the toggle, 
       * toggleMute(false) for unchecking, and 
       * toggleMute to toggle  
       */
      toggleMute: function(mode,value){
        mode = mode === undefined ? !this.muted : mode;
        if(mode){
          this.media.mute();
          this.media.setVolume(0);
        } else {
          this.media.unMute();
          this.media.setVolume(Math.max(value,1));
        }
      },
    });
  </script>
</dom-module>
