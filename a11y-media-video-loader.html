<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="a11y-media-behaviors.html">


<!--
`a11y-media-video-loader`
A LRN element

@demo demo/index.html

@microcopy - the mental model for this element

  <a11y-media-video-loader 
    accent-color$="[[accentColor]]"             // Optional accent color for controls, 
                                                // using the following materialize colors: 
                                                // red, pink, purple, deep-purple, indigo, blue, 
                                                // light blue, cyan, teal, green, light green, lime, 
                                                // yellow, amber, orange, deep-orange, and brown. 
                                                // Default is null. 
    allow-fullscreen$="[[allowFullscreen]]"         // Allow fullscreen mode?
    audio-only$="[[audioOnly]]"                 // Is media audio only?
    autoplay$="[[autoplay]]"                    // Is player set to autoplay (not recommended for a11y)?
    cc$="[[cc]]"                                // Are closed captions toggled?
    custom-microcopy$="[[customMicrocopy]]"     // Optional customization or text and icons
    dark$="[[dark]]"                            // Is the color scheme dark? Default is light.    
    disableFullscreen$="[[disableFullscreen]]"  // Is full screen mode disabled?
    fullscreen$="[[fullscreen]]"                // Is full screen mode toggled on?
    height$="[[height]]"                        // The height of player
    hide-elapsed-time$="[[hideElapsedTime]]"    // Is elapsed time hidden?
    lang$="[[lang]]"                            // The language of the media
    loop$="[[loop]]"                            // Is video on a loop?
    muted$="[[muted]]"                          // Is video muted?
    volume$="[[volume]]"                        // The initial volume of the video
    width$="[[width]]">                         // The width of player
                                                // video source and tracks 
    <source src="/path/to/video.mp4" type="video/mp4">
    <source src="/path/to/video.webm" type="video/webm">
    <track label="English" kind="subtitles" srclang="en" src="path/to/subtitles/en.vtt" default>
    <track label="Deutsch" kind="subtitles" srclang="de" src="path/to/subtitles/de.vtt">
    <track label="EspaÃ±ol" kind="subtitles" srclang="es" src="path/to/subtitles/es.vtt">
  </a11y-media-video-loader>
-->

<dom-module id="a11y-media-video-loader">
  <template>
    <video id="video" 
      autoplay$="[[autoplay]]" 
      hidden$="[[audioOnly]]"
      lang$="[[lang]]"
      loop$="[[loop]]" 
      muted$="[[muted]]" 
      preload="metadata">
      <template is="dom-repeat" items="[[sources]]" as="source">
        <source src$="[[source.src]]" type$="[[source.type]]">
      </template>
      <template is="dom-repeat" items="[[tracks]]" as="track">
        <source src$="[[track.src]]" label$="[[track.label]]" kind$="[[track.kind]]" srclang$="[[track.srclang]]" default$="[[track.default]]">
      </template>
      HTML5 video not supported 
    </video>
  </template>

  <script>
    Polymer({

      is: 'a11y-media-video-loader',
      
      behaviors: [ 
        a11yMediaBehaviors.MediaProps, 
        a11yMediaBehaviors.GeneralFunctions 
      ], 

      ready: function(){
        let root = this;
        root.media = root.$.video !== undefined ? root.$.video : root.$.audio
        root.status = 'Loading...';

        // handles loaded metadata
        root.addEventListener('loadedmetadata',function(){

          root.duration = root.media.duration > 0 ? root.media.duration: 0; 
          root.status = root._convertTime(0,root.media.duration)+'/'+root._convertTime(root.media.duration);
          root.tracks = [];
          root.volume = root.muted ? 0 : Math.max(this.volume,10);
          
          // adjusts aspect ratio
          root.aspectRatio = root.media.videoHeight/root.media.videoWidth * 100;
          if(root.width === undefined && root.height === undefined) {
            root.width = root.media.videoWidth;
            root.height = root.media.videoHeight;
          } else (root.width === undefined){
            root.width = (root.height * root.aspectRatio / 100);
          } else {
            root.height = (root.width / root.aspectRatio / 100);
          }
          console.log(root);
          
          // gets cues from tracks
          let tracks = [];
          for(i in root.media.textTracks) {
            if (root.media.textTracks[i] !== null) {
              let track = root.media.textTracks[i], loaded = track.cues !== undefined, complete = 0, label = track.label, lang = track.language, text = label !== undefined ? label : lang !== undefined ? lang : 'Track '+i, cues;
              
              root.setAttribute('has-captions',true);
              if(!loaded) {
                track.mode = 'showing';
                let temp = setInterval(() => {
                  if (track.cues.length > 0) {
                    track.mode = 'hidden';
                    let cues = Object.keys(track.cues).map(function(key) { 
                      return {
                        "order": track.cues[key].id,
                        "seek": track.cues[key].startTime,
                        "start": root._convertTime(track.cues[key].startTime,root.media.duration),
                        "end": root._convertTime(track.cues[key].endTime,root.media.duration), 
                        "text": track.cues[key].text
                      };
                      tracks.push({
                        'text': text, 
                        'language': track.language, 
                        'value': i,
                        'curs': cues
                      });
                      track.oncuechange = function(e){
                        this.fire('active-cue-change',Object.keys(e.currentTarget.activeCues).map(function(key) { 
                          return e.currentTarget.activeCues[key].id;
                        }));
                      };
                    });
                    complete++;
                    if (complete === tracks.length && root.__transcript !== null) {
                      root.set('tracks', tracks);
                      root.fire('tracks-loaded',root.tracks);
                    }
                    clearInterval(temp);
                  }
                },1);
              }
            }
          }
        });
      },
      /** 
       * selects a specific track by index
       */
      selectTrack: function(index){
        for(i in this.media.textTracks) {
          if (index == i) {
            this.media.textTracks[i].mode = 'showing';
            this.selectedTrack = this.media.textTracks[i];
            this.selectedTrackId = i;
          } else if (this.media.textTracks[i] !== null) {
            this.media.textTracks[i].mode = 'hidden';
          }
        }
      },
      /** 
       * plays the media 
       */
      play: function(){
        this.media.play();
      },
      /** 
       * pauses the media 
       */
      pause: function(){
        this.media.pause(); 
      },
      /** 
       * stops the media 
       */
      stop: function(){
        this.pause();
        this.seek(0);
      },
      /** 
       * restarts the media 
       */
      restart: function(){
        this.seek(0);
        this.play();
      },
      /** 
       * seeks media backward at a set increment
       */
      rewind: function(amt){
        amt = amt !== undefined ? amt : 1;
        this.seek(Math.max(this.__src.currentTime - amt,0));
      },
      /** 
       * seeks media forward at a set increment
       */
      forward: function(amt){
        amt = amt !== undefined ? amt : 1;
        this.seek(Math.min(this.__src.currentTime + amt,this.__src.duration));
      },
      /** 
       * seeks to a specific time 
       */
      seek: function(time){
        this.media.currentTime = time;
      },
      /** 
       * toggles captions:
       * toggleCC(true) to check the toggle, toggleCC(false) for unchecking, and toggleCC to toggle  
       */
      toggleCC: function(mode){
        mode = mode === undefined ? !this.cc : mode;
        this.cc = mode;
        if (this.selectedTrack !== undefined && mode == true) {
          this.selectedTrack.mode = 'showing';
          this.$.video.textTracks.value = this.selectedTrackId;
        } else if (this.selectedTrack !== undefined) {
          this.selectedTrack.mode = 'hidden';
          this.$.video.textTracks.value = '';
        }
      },
      /** 
       * set volume of media
       */
      setVolume: function(value){
        this.media.volume = value;
        this.media.muted = value === null || value === 0;
      },
      /** 
       * set speed/playback rate of media
       */
      setPlaybackRate: function(value){
        this.media.playbackRate = value !== null ? value : 1;
      },
      /** 
       * toggles autoplay:
       * toggleAutoplay(true) to check the toggle, 
       * toggleAutoplay(false) for unchecking, and 
       * toggleAutoplay to toggle  
       */
      toggleAutoplay: function(mode){
        mode = mode === undefined ? !this.muted : mode;
        this.media.autoplay = mode;
      },
      /** 
       * toggles looping:
       * toggleLoop(true) to check the toggle, toggleLoop(false) for unchecking, and toggleLoop to toggle  
       */
      toggleLoop: function(mode){
        mode = mode === undefined ? !this.loop : mode;
        this.media.loop = mode;
      },
      /** 
       * toggles mute:
       * toggleMute(true) to check the toggle, 
       * toggleMute(false) for unchecking, and 
       * toggleMute to toggle  
       */
      toggleMute: function(mode,value){
        mode = mode === undefined ? !this.muted : mode;
        this.media.muted = mode;
        this.media.volume = mode ? 0 : Math.max(value,1);
      },
    });
  </script>
</dom-module>
