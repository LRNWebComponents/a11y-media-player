<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="../paper-slider/paper-slider.html">
<link rel="import" href="../web-animations-js/web-animations-next-lite.min.html">
<link rel="import" href="screenfull-lib.html">
<link rel="import" href="a11y-media-behaviors.html">
<link rel="import" href="a11y-media-play-button.html">
<link rel="import" href="a11y-media-controls.html">
<link rel="import" href="a11y-media-transcript.html">

<!--
`a11y-media-player`
A LRN element

@demo demo/index.html

@microcopy - the mental model for this element

  <a11y-media-player 
    autoplay$="[[autoplay]]"                    // Is player set to autoplay (not recommended for a11y)?
    cc$="[[cc]]"                                // Are closed captions toggled?
    disableFullscreen$="[[disableFullscreen]]"  // Is full screen mode disabled?
    fullscreen$="[[fullscreen]]"                // Is full screen mode toggled on?
    height$="[[height]]"                        // The height of player
    hide-elapsed-time$="[[hideElapsedTime]]"    // Is elapsed time hidden?
    lang$="[[lang]]"                            // The language of the media
    loop$="[[loop]]"                            // Is video on a loop?
    muted$="[[muted]]"                          // Is video muted?
    volume$="[[volume]]"                        // The initial volume of the video
    width$="[[width]]">                         // The width of player
                                                // video source and tracks 
    <source src="/path/to/video.mp4" type="video/mp4">
    <source src="/path/to/video.webm" type="video/webm">
    <track label="English" kind="subtitles" srclang="en" src="path/to/subtitles/en.vtt" default>
    <track label="Deutsch" kind="subtitles" srclang="de" src="path/to/subtitles/de.vtt">
    <track label="EspaÃ±ol" kind="subtitles" srclang="es" src="path/to/subtitles/es.vtt">
  </a11y-media-player>

 Basic customization of player:
--a11y-media-text-color: text color, default is #bbbbbb
--a11y-media-bg-color: background color, default is #000000
--a11y-media-faded-bg-color: a subtler version of background color, default is #444444
--a11y-media-hover-color: text color on hover, default is #ffffff
--a11y-media-accent-color: an accent color, default is #00eeff
--a11y-media-faded-accent-color: a subtler version of accent color, default is #4E7373
 
 Custom styles for player buttons:
--a11y-media-button-color: button text color, default is --a11y-media-text-color
--a11y-media-button-bg-color: button background color, default is --a11y-media-bg-color
--a11y-media-button-hover-color: button text color when focused/hovered, default is --a11y-media-hover-color
--a11y-media-button-hover-bg-color: button background color when focused/hovered, default is --a11y-media-bg-color
 
 Custom styles for player settings menu:
--a11y-media-settings-menu-color: settings menu text color, default is --a11y-media-text-color
--a11y-media-settings-menu-bg-color: settings menu background color, default is --a11y-media-bg-color
 
 Custom styles for player toggle buttons:
--a11y-toggle-off-color: color of toggle button when off, default is #f8f8f8
--a11y-toggle-on-color: color of toggle button when on, default is --a11y-media-accent-color
 
 Custom styles for player slider buttons:
--a11y-media-slider-primary-color: primary slider color, default is --a11y-media-accent-color
--a11y-media-slider-buffer-color: slider buffer color, default is --a11y-media-faded-accent-color
--a11y-media-slider-pin-color: color of the pin that shows slider value, default is #444444
--a11y-media-slider-knob-color: slider knob color, default is --a11y-media-accent-color

 Custom styles for player volume slider:
--a11y-media-volume-primary-color: volume slider color, default is #00eeff
--a11y-media-volume-pin-color: color of the pin that shows volume slider value, default is #444444
--a11y-media-volume-knob-color: volume slider knob color, default is #00eeff
--a11y-media-volume-knob-start-color: knob color at the start of volume slider, default is --a11y-media-hover-color
--a11y-media-volume-knob-end-color: knob color at the end of volume slider, default is --a11y-media-volume-knob-color

 Custom styles for player speed slider:
--a11y-media-speed-primary-color: speed slider color, default is #00eeff
--a11y-media-speed-pin-color: color of the pin that shows speed slider value, default is #444444
--a11y-media-speed-knob-color: volume slider knob color, default is #00eeff
--a11y-media-speed-knob-start-color: knob color at the start of speed slider, default is --a11y-media-speed-knob-color
--a11y-media-speed-knob-end-color: knob color at the end of speed slider, default is --a11y-media-speed-knob-color
-->

<dom-module id="a11y-media-player">
  <template>
    <style is="custom-style">
      :host {
        display: block;
        max-width: 100%;
        color:  var(--a11y-media-text-color, #ffffff);
        background-color: var(--a11y-media-bg-color,#000000);
      }
      :host #player-inner {
        z-index: 1;
      }
      :host #media {
        padding-top: 56.25%;
        position: relative;
      }
      :host #media,
      :host #media > *, 
      :host #slider,
      :host #controls {
        width: 100%;
      }
      :host, :host #controls {
        background-color: var(--a11y-media-bg-color, #000000);
        color: var(--a11y-media-color, #bbbbbb);

        /* buttons */
        --a11y-media-settings-menu-color: var(--a11y-media-color, #bbbbbb);
        --a11y-media-settings-menu-bg-color: var(--a11y-media-bg-color, #000000);
        
        /* buttons */
        --a11y-media-button-bg-color: var(--a11y-media-bg-color, #000000);
        --a11y-media-button-color: var(--a11y-media-color, #bbbbbb);
        --a11y-media-button-hover-bg-color: var(--a11y-media-bg-color, #000000);
        --a11y-media-button-hover-color: var(--a11y-media-hover-color, #ffffff);
        
        /* toggle button */
        --paper-toggle-button-unchecked-bar-color: var(--a11y-media-toggle-off-color, var(--a11y-media-color, #bbbbbb));
        --paper-toggle-button-unchecked-button-color: var(--a11y-media-toggle-off-color, var(--a11y-media-color, #bbbbbb));
        --paper-toggle-button-checked-bar-color: var(--a11y-media-toggle-on-color, var(--a11y-media-accent-color, #00eeff));
        --paper-toggle-button-checked-button-color: var(--a11y-media-toggle-on-color, var(--a11y-media-accent-color, #00eeff));
        
        /* slider */
        --paper-slider-active-color: var(--a11y-media-slider-primary-color, var(--a11y-media-accent-color, #00eeff));
        --paper-slider-secondary-color: var(--a11y-media-slider-buffer-color, var(--a11y-media-faded-accent-color, #4E7373));
        --paper-slider-pin-color: var(--a11y-media-slider-pin-color, var(--a11y-media-faded-bg-color, #444444));
        --paper-slider-pin-start-color: var(--a11y-media-slider-pin-color, var(--a11y-media-faded-bg-color, #444444));
        --paper-slider-pin-end-color:  var(--a11y-media-slider-pin-color, var(--a11y-media-faded-bg-color, #444444));
        --paper-slider-knob-color: var(--a11y-media-slider-knob-color, var(--a11y-media-accent-color, #00eeff));
        --paper-slider-knob-start-border-color: var(--a11y-media-bg-color, #000000);
        --paper-slider-knob-end-border-color: var(--a11y-media-bg-color, #000000);
        --paper-slider-knob-start-color: var(--a11y-media-bg-color, #000000);
        --paper-slider-knob-end-color: var(--a11y-media-bg-color, #000000);
        
        /* volume slider */
        --a11y-media-volume-active-color: var(--a11y-media-slider-primary-color, var(--a11y-media-accent-color, #00eeff));
        --a11y-media-volume-knob-color: var(--a11y-media-slider-knob-color, var(--a11y-media-accent-color, #00eeff));;
        --a11y-media-volume-knob-start-color: var(--a11y-media-hover-color, #ffffff);
        --a11y-media-volume-knob-end-color: --a11y-media-volume-knob-color;
        
        /* speed slider */
        --a11y-media-speed-active-color: var(--a11y-media-slider-primary-color, var(--a11y-media-accent-color, #00eeff));
        --a11y-media-speed-knob-color: var(--a11y-media-slider-knob-color, var(--a11y-media-accent-color, #00eeff));;
        --a11y-media-speed-knob-start-color: --a11y-media-speed-knob-color;
        --a11y-media-speed-knob-end-color: --a11y-media-speed-knob-color;
      }
      :host #video {
        position: absolute;
        top: 0;
        left: 0;
      }
      :host a11y-media-play-button {
        padding-top: 56.25%;
        --a11y-media-play-button-text: {
          fill: var(--a11y-play-button-text-color, #ffffff);
        };
      }
      @media print {
        :host {
          color: #000000;
          background-color: #f0f0f0;
          padding: 15px;
          width: auto;
        }
        :host > * {
          display: none;
        }
        :host:before {
          display: block;
          content: '(Interactive Media)';
          font-style: italic;
        }
      }
    </style>
    <div id="player">
      <div id="player-inner">
        <div id="media">
          <video 
            autoplay$="[[autoplay]]" 
            id="video" 
            loop$="[[loop]]" 
            muted$="[[muted]]" 
            preload="metadata">
            <slot></slot>
            HTML5 video not supported 
          </video>
          <a11y-media-play-button id="playbutton" playing$="[[__playing]]"></a11y-media-play-button>
        </div>
      </div>
      <paper-slider 
        id="slider" 
        max$="[[__duration]]" 
        pin 
        secondary-progress$="[[__buffered]]" 
        value$="[[__elapsed]]">
      </paper-slider>
    </div>
    <a11y-media-controls 
      allow-fullscreen$="[[allowFullscreen]]"
      autoplay$="[[autoplay]]"
      cc$="[[cc]]"
      fullscreen$="[[fullscreen]]" 
      hide-elapsed-time$="[[hideElapsedTime]]"
      id="controls"
      length="[[__length]]"
      loop$="[[loop]]"
      muted$="[[muted]]"
      responsive-size="[[responsiveSize]]"
      playing$="[[__playing]]"
      playback-rate="[[playbackRate]]"
      volume="[[__volume]]">
    </a11y-media-controls>
  </template>

  <script>
    Polymer({

      is: 'a11y-media-player',

      listeners: {
        'controls-change': '_onControlsChanged',
        'play-button-tapped': 'play'
      },
      
      behaviors: [
        a11yMediaBehaviors.PlayerBehaviors, 
        a11yMediaBehaviors.UtilityFunctions
      ],
      
      properties: {
        //
      },

      /**
        * initializes slider metadata
        */
      created: function(){
      },

      /**
        * calls responsive-utility to get parent's responsive size
        */ 
      attached: function(){
        this._addResponsiveUtility();
      },
      ready: function(){
        let root = this, video = root.$.video, tracks = new Array();
        root.__length = 'Loading...';
        root.__slider = root.$.slider;
        root.__volume = root.muted ? 0 : Math.max(this.volume,10);
        root.__resumePlaying = false;
        root.__showFullscreen = this.allowFullscreen && screenfull.enabled;

        // handles fullscreen
        if(root.__showFullscreen) {
          screenfull.on('change', () => { this.fullscreen = screenfull.isFullscreen });
        }
        // handles dragging with a mouse
        root.$.slider.addEventListener('dragging-changed', (e) => {
          // when dragging stops, seeks to that value and 
          // if the video was playing before the dragging, resumes it
          if (!root.$.slider.dragging) { 
            root.seek(root.$.slider.immediateValue);
            root.__resumePlaying = false;
          }
        });
        // handles slider focus
        root.$.slider.addEventListener('focused-changed', (e) => {
          // temporarily pauses playback so that a value can be selected, 
          // but notes if playing should be resumed
          if(root.$.slider.focused){
            if (root.__playing) root.__resumePlaying = true;
            root.pause();
          } else {
            root.seek(root.$.slider.value);
            root.__resumePlaying = false;
          }
        });
        //adjusts video width and height based on attributes
        if (root.width === 'unset' && root.height === 'unset'){
          root.style.width = '100%';  
        } else if (root.width === 'unset' && root.height !== 'unset') {
          root.style.height = root.height;
        } else {
          root.style.width = root.width;  
        }
        // handles loaded metadata
        video.addEventListener('loadedmetadata',function(){
          // adjusts aspect ratio
          if (root.width !== 'unset') root.setAttribute('width',root.width);
          if (root.height !== 'unset') root.setAttribute('width',root.height);
          let aspect = video.videoHeight/video.videoWidth * 100;
          root.$.playbutton.style.paddingTop = aspect+'%';
          root.$.media.style.paddingTop = aspect+'%';
          // gets and converts video duration
          root.__duration = video.duration > 0 ? video.duration: 0; 
          root.__length = root._convertTime(0,video.duration)+'/'+root._convertTime(video.duration);

          // hides the video subtitles and captions and adds them to the tracks dropdown-select
          if (video.textTracks.length > 0) root.selectTrack(0);
          
          // gets cues from tracks
          for(i in video.textTracks) {
            let cues = {};
            if (video.textTracks[i] !== null) {
              let text = video.textTracks[i].label !== undefined ? video.textTracks[i].label : video.textTracks[i].language;
              if(text !== undefined){
                let track = video.textTracks[i];
                root.setAttribute('has-captions',true);
                tracks.push({
                  'text': text, 
                  'language': track.language, 
                  'value': i
                });
                track.oncuechange = function(e){
                  if (root.__transcript !== undefined && root.__transcript !== null) {
                    root.__transcript.activeCues = Object.keys(e.currentTarget.activeCues).map(function(key) { 
                      return e.currentTarget.activeCues[key].id;
                    });
                  }
                };
              }
            }
          }
          root.set('__tracks', tracks);
          if (root.__transcript !== undefined && root.__transcript !== null) {
            let complete = 0;
            for (var i=0 ; i < tracks.length; i++) {
              let itrack = tracks[i], track = video.textTracks[i], loaded = itrack.cues !== undefined;
              if(!loaded){
                track.mode = 'showing';
                let temp = setInterval(() => {
                  if (track.cues.length > 0) {
                    track.mode = 'hidden';
                    itrack.cues = Object.keys(track.cues).map(function(key) { 
                      return {
                        'order': Number(key),
                        'seek': track.cues[key].startTime,
                        'start': root._convertTime(track.cues[key].startTime,video.duration),
                        'end': root._convertTime(track.cues[key].endTime,video.duration), 
                        'text': track.cues[key].text
                      };
                    });
                    complete++;
                    if (complete === tracks.length && root.__transcript !== null) {
                      root.__transcript.setTracks(tracks);
                      root.__transcript.setAttribute('selected-transcript',root.__selectedTrackId);
                    }
                    clearInterval(temp);
                  }
                },1);
              }
            }
          }
        });
        // when transcript is ready associate it with the player
        document.body.addEventListener('transcript-ready',function(e){
          if(root.getAttribute('id') === e.detail.mediaId || root === e.detail.media) {
            root.__transcript = e.detail;
            if (root.__tracks !== undefined) root.__transcript.setTracks(tracks);
            root.__transcript.addEventListener('cue-seek',function(e){
              root.seek(e.detail.cue.seek);
            });
          }
        });
      },
      /** 
       * plays the media 
       */
      play: function(e){
        let root = this, video = root.$.video;
        root.__playing = true;
        if (e === undefined || e.detail === root.$.playbutton) {
          // while playing, update the slider and length
          root.__playProgress = setInterval(() => {
            root.__elapsed = video.currentTime > 0 ? video.currentTime : 0;
            root.__length = root._convertTime(video.currentTime,video.duration) +'/'+ root._convertTime(video.duration);
            // if the video reaches the end and is not set to loop, stop
            if(root.__elapsed === root.__duration && !root.loop){
              root.__playing = false;
              clearInterval(root.__playProgress);
            }
            //updated buffered section of the slider
            root.__buffered = video.buffered.length > 0 ? video.buffered.end(0) : root.__elapsed;
          }, 1);

          root.$.video.play();
        }
      },
      /** 
       * pauses the media 
       */
      pause: function(){
        let root = this;
        root.__playing = false;
        root.$.video.pause();
        //stop updating the slider and length
        clearInterval(root.__playProgress); 
      },
      /** 
       * stops the media 
       */
      stop: function(){
        this.pause();
        this.seek(0);
      },
      /** 
       * restarts the media 
       */
      restart: function(){
        this.seek(0);
        this.play();
      },
      /** 
       * seeks media backward at a set increment
       */
      rewind: function(amt){
        amt = amt !== undefined ? amt : 1;
        this.seek(Math.max(this.$.video.currentTime - amt,0));
      },
      /** 
       * seeks media forward at a set increment
       */
      forward: function(amt){
        amt = amt !== undefined ? amt : 1;
        this.seek(Math.min(this.$.video.currentTime + amt,this.$.video.duration));
      },
      /** 
       * seeks to a specific time 
       */
      seek: function(time){
        let seekable = this.$.video.seekable;
        if (seekable.length > 0 && time >= seekable.start(0) && time <= seekable.end(0)) {
          this.$.video.currentTime = time;
          this.__elapsed = time;
          this.__length = this._convertTime(this.$.video.currentTime,this.$.video.duration) +'/'+ this._convertTime(this.$.video.duration);
          if (this.__resumePlaying) this.play();
        }
      },
      /** 
       * selects a specific track by index
       */
      selectTrack: function(index){
        for(i in this.$.video.textTracks) {
          if (index == i) {
            this.$.video.textTracks[i].mode = 'showing';
            this.__selectedTrack = this.$.video.textTracks[i];
            this.__selectedTrackId = i;
          } else if (this.$.video.textTracks[i] !== null) {
            this.$.video.textTracks[i].mode = 'hidden';
          }
        }
        if (this.__transcript !== null && this.__transcript.tracks !== null) {
          this.__transcript.setAttribute('selected-transcript',this.__selectedTrackId);
        }
      },
      /** 
       * toggles captions:
       * toggleCC(true) to check the toggle, toggleCC(false) for unchecking, and toggleCC to toggle  
       */
      toggleCC: function(mode){
        mode = mode === undefined ? !this.cc : mode;
        this.cc = mode;
        if (this.__selectedTrack !== undefined && mode == true) {
          this.__selectedTrack.mode = 'showing';
          this.$.tracks.value = this.__selectedTrackId;
        } else if (this.__selectedTrack !== undefined) {
          this.__selectedTrack.mode = 'hidden';
          this.$.tracks.value = '';
        }
      },
      /** 
       * toggles mute:
       * toggleMute(true) to check the toggle, 
       * toggleMute(false) for unchecking, and 
       * toggleMute to toggle  
       */
      toggleMute: function(mode){
        mode = mode === undefined ? !this.muted : mode;
        this.muted = mode;
        this.__volume = this.muted ? 0 : Math.max(this.volume,10);
        this.$.video.volume = this.muted ? 0 : Math.max(this.volume/100,0.1);
        this.$.video.muted = this.muted;
      },
      /** 
       * toggles autoplay:
       * toggleAutoplay(true) to check the toggle, 
       * toggleAutoplay(false) for unchecking, and 
       * toggleAutoplay to toggle  
       */
      toggleAutoplay: function(mode){
        mode = mode === undefined ? !this.muted : mode;
        this.autoplay = mode;
      },
      /** 
       * set volume of media
       */
      setVolume: function(value){
        this.volume = value !== null ? value : 70;
        this.$.video.volume = this.volume !== null ? value/100 : 0.7;
        this.muted = value === null || value === 0;
      },
      /** 
       * set speed/playback rate of media
       */
      setPlaybackRate: function(value){
        this.$.video.playbackRate = value !== null ? value : 1;
      },
      /** 
       * toggles looping:
       * toggleLoop(true) to check the toggle, toggleLoop(false) for unchecking, and toggleLoop to toggle  
       */
      toggleLoop: function(mode){
        mode = mode === undefined ? !this.loop : mode;
        this.loop = mode;
        this.$.video.muted = this.loop;
      },
      /**
       * determine which button was clicked and act accordingly 
       */
       _onControlsChanged: function(e){
        let action = e.detail.label !== undefined ? e.detail.label : e.detail.id;
        if (action === 'backward') {
          this.rewind(this.$.video.duration/20);
        } else if (action === 'closed captions' || action === 'captions') {
          this.toggleCC();
        } else if (action === 'forward') {
          this.forward(this.$.video.duration/20);
        } else if (action === 'full screen') {
          screenfull.toggle(this);
        } else if (action === 'loop') {
          this.toggleLoop();
        } else if (action === 'mute' || action === 'unmute') {
          this.toggleMute();
        } else if (action === 'pause') {
          this.pause();
        } else if (action === 'play') {
          this.play();
        } else if (action === 'restart') {
          this.seek(0);
          this.play();
        } else if (action === 'speed') {
          this.setPlaybackRate(e.detail.value);
        } else if (action === 'volume') {
          this.setVolume(e.detail.value);
        }
      },
      /**
        * set play/pause button 
        */
      _convertTime: function(val,max){
        max = max === undefined ? val : max;
        let a = (val) => { return val < 10 ? '0' + val : val; }, 
        b = (val,i,none) => { return max >= i ? a(Math.floor(val/i))+':' : none },
        c = (val) => { return val < 100 ? val+'0' : val };
        return b(val,3600,'')+b(val%3600,60,'00:')+a(Math.round(val%60));
      }
    });
  </script>
</dom-module>
